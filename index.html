<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="jspsych/jspsych.js"></script>
    <script src="jspsych/jspsych-psychophysics.js"></script>
    <script src="jspsych/plugin-html-button-response.js"></script>
    <script src="jspsych/plugin-fullscreen.js"></script>
    <script src="jspsych/plugin-virtual-chinrest.js"></script>
    <script src="src/helper.js"></script>
    <link href="jspsych/jspsych.css" rel="stylesheet" type="text/css"/>
    <link href="src/stylesheet.css" rel="stylesheet" type="text/css"/>
    <title>Visual Search Task</title>
</head>
<body> 
</body>
<script>

    // Initialize jsPsych
    const jsPsych = initJsPsych({
        on_finish: () => {
            jsPsych.data.displayData();
        }
    });


    // Run in JATOS server?
    const jatos_run = window.jatos !== undefined || false;

    const timeline = [];  

    const welcome = {
    type: jsPsychHtmlButtonResponse,
    stimulus: "<p>Experiment under construction.</p></br>",
    choices: ['Continue']
    };

    timeline.push(welcome);

    /*
    Idea for conditional trials. Incude event in timeline but make it conditional to timelines variables
    */
    const resize = {
        type: jsPsychVirtualChinrest,
        blindspot_reps: 3,
        resize_units: "none",
        on_finish: () => {
            //Fade to black transition
            document.body.classList.add("black");;
        },
        post_trial_gap: 2000,
    };


    const full_on = {
        type: jsPsychFullscreen,
        fullscreen_mode: true,
        message: "<p>Antes de empezar, pulsa el bot√≥n para entrar en modo pantalla completa.</p>",
        button_label: "Entrar en pantalla completa",
    }

    // Experimental trial

    const trial = {
        type: jsPsychPsychophysics,
        stimuli: () => {
            const sF  = jsPsych.data.get().last(1).values()[0].px2deg;
            const targetPos = jsPsych.timelineVariable("targetPos");
            const singPos = jsPsych.timelineVariable("singPos");
            const dimension = jsPsych.timelineVariable("dimension");
            return draw_display(1*sF, 0.1*sF, 4*sF, dimension, targetPos, singPos, jsPsych.timelineVariable("orientation"));
        },
        choices: ['y', 'n'], 
        background_color: '#000000',
        canvas_width: () => {
            const sF  = jsPsych.data.get().last(1).values()[0].px2deg;
            return sF*11;
        },
        canvas_height: () => {
            const sF  = jsPsych.data.get().last(1).values()[0].px2deg;
            return sF*11;
        },
        data: () => {
            const sPos = jsPsych.timelineVariable("singPos")
            return {
                px2deg: jsPsych.data.get().last(1).values()[0].px2deg,
                tPos: jsPsych.timelineVariable("targetPos"),
                sPos: sPos,
                counterbalance: jsPsych.timelineVariable("dimension"),
                condition: (sPos < 0)? "Absent": (sPos === HPDL) ? "HPDL": "LPDL"
            }
        },
        on_finish: (data) => {
            data.correct_response = (jsPsych.timelineVariable("orientation") == "vertical") ? "f":"c";
            data.correct = (jsPsych.pluginAPI.compareKeys(data.response, data.correct_response))? 1: 0;
        },
        post_trial_gap: 500 + Math.floor(Math.random()*201),
        trial_duration: 3000,
    };

    const procedure = {
        timeline: [trial],
        timeline_variables: trialObj,
        repetitions: 1,
        randomize_order: false,
    }

    timeline.push(resize, procedure);

    jsPsych.run(timeline);

</script>
</html>